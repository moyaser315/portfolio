---
// FluidCursor.astro
---

<canvas id="fluid-cursor-canvas"></canvas>

<script>
  import { Renderer, Camera, Transform, Mesh, Program, Geometry, Texture, RenderTarget } from 'https://cdn.skypack.dev/ogl';

  class FluidCursor {
    constructor() {
      this.canvas = document.getElementById('fluid-cursor-canvas');
      this.renderer = new Renderer({ canvas: this.canvas, alpha: true });
      this.gl = this.renderer.gl;
      
      // Set canvas size
      this.canvas.style.position = 'fixed';
      this.canvas.style.top = '0';
      this.canvas.style.left = '0';
      this.canvas.style.pointerEvents = 'none';
      this.canvas.style.zIndex = '9999';
      
      this.camera = new Camera(this.gl);
      this.camera.position.z = 1;
      
      this.scene = new Transform();
      
      this.mouse = { x: 0, y: 0 };
      this.velocity = { x: 0, y: 0 };
      this.lastMouse = { x: 0, y: 0 };
      
      this.initFluid();
      this.addEventListeners();
      this.resize();
      this.render();
    }
    
    initFluid() {
      // Create render targets for fluid simulation
      this.fbo = {
        read: new RenderTarget(this.gl, { width: 128, height: 128 }),
        write: new RenderTarget(this.gl, { width: 128, height: 128 }),
        swap: () => {
          let temp = this.fbo.read;
          this.fbo.read = this.fbo.write;
          this.fbo.write = temp;
        }
      };
      
      // Fluid simulation shaders
      const fluidVertex = `
        attribute vec2 position;
        varying vec2 vUv;
        void main() {
          vUv = position * 0.5 + 0.5;
          gl_Position = vec4(position, 0.0, 1.0);
        }
      `;
      
      const fluidFragment = `
        precision highp float;
        uniform sampler2D tFluid;
        uniform vec2 uMouse;
        uniform vec2 uVelocity;
        uniform float uTime;
        varying vec2 vUv;
        
        void main() {
          vec2 uv = vUv;
          vec4 fluid = texture2D(tFluid, uv);
          
          // Distance from mouse with larger influence radius
          float dist = distance(uv, uMouse);
          float influence = 1.0 - smoothstep(0.0, 0.25, dist);
          
          // Add velocity based influence with more intensity
          vec2 vel = uVelocity * influence * 0.25;
          fluid.xy += vel;
          
          // Less decay for more persistent trails
          fluid *= 0.992;
          
          // Simple curl noise for organic movement (no visible patterns)
          float curl = sin(uTime * 0.0005 + uv.x * 5.0) * cos(uTime * 0.0005 + uv.y * 5.0) * 0.005;
          fluid.xy += curl;
          
          gl_FragColor = fluid;
        }
      `;
      
      // Display shader
      const displayVertex = `
        attribute vec2 position;
        varying vec2 vUv;
        void main() {
          vUv = position * 0.5 + 0.5;
          gl_Position = vec4(position, 0.0, 1.0);
        }
      `;
      
      const displayFragment = `
        precision highp float;
        uniform sampler2D tFluid;
        uniform vec2 uMouse;
        uniform float uTime;
        varying vec2 vUv;
        
        void main() {
          vec2 uv = vUv;
          vec4 fluid = texture2D(tFluid, uv);
          
          // Distance from mouse for glow effect
          float dist = distance(uv, uMouse);
          float glow = 1.0 - smoothstep(0.0, 0.6, dist);
          float innerGlow = 1.0 - smoothstep(0.0, 0.3, dist);
          
          // Colors matching your theme
          vec3 primaryColor = vec3(0.55, 0.36, 0.96);     // Your primary purple (140, 92, 245)
          vec3 highlightColor = vec3(0.75, 0.55, 1.0);    // Bright purple
          
          // Only show effect around mouse and fluid movement
          vec3 color = vec3(0.0);
          
          // Add color only from mouse glow
          color += primaryColor * glow * 0.4;
          color += highlightColor * innerGlow * 0.3;
          
          // Add color only from fluid trails (mouse movement)
          float fluidIntensity = length(fluid.xy) * 2.0;
          color += primaryColor * fluidIntensity * 0.6;
          
          // Alpha only from mouse interaction and fluid movement
          float alpha = glow * 0.5 + innerGlow * 0.3 + fluidIntensity * 0.4;
          
          gl_FragColor = vec4(color, alpha);
        }
      `;
      
      // Create geometry (fullscreen quad)
      const geometry = new Geometry(this.gl, {
        position: { size: 2, data: new Float32Array([-1, -1, 3, -1, -1, 3]) },
      });
      
      // Fluid simulation program
      this.fluidProgram = new Program(this.gl, {
        vertex: fluidVertex,
        fragment: fluidFragment,
        uniforms: {
          tFluid: { value: this.fbo.read.texture },
          uMouse: { value: [0, 0] },
          uVelocity: { value: [0, 0] },
          uTime: { value: 0 }
        }
      });
      
      // Display program
      this.displayProgram = new Program(this.gl, {
        vertex: displayVertex,
        fragment: displayFragment,
        uniforms: {
          tFluid: { value: this.fbo.read.texture },
          uMouse: { value: [0, 0] },
          uTime: { value: 0 }
        }
      });
      
      this.mesh = new Mesh(this.gl, { geometry, program: this.fluidProgram });
      this.displayMesh = new Mesh(this.gl, { geometry, program: this.displayProgram });
    }
    
    addEventListeners() {
      window.addEventListener('mousemove', (e) => {
        const rect = this.canvas.getBoundingClientRect();
        this.mouse.x = (e.clientX - rect.left) / rect.width;
        this.mouse.y = 1.0 - (e.clientY - rect.top) / rect.height;
        
        // Calculate velocity
        this.velocity.x = (this.mouse.x - this.lastMouse.x) * 10;
        this.velocity.y = (this.mouse.y - this.lastMouse.y) * 10;
        
        this.lastMouse.x = this.mouse.x;
        this.lastMouse.y = this.mouse.y;
      });
      
      window.addEventListener('resize', () => this.resize());
    }
    
    resize() {
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      this.camera.perspective({ aspect: window.innerWidth / window.innerHeight });
    }
    
    render() {
      const time = performance.now();
      
      // Update fluid simulation
      this.renderer.render({
        scene: this.mesh,
        camera: this.camera,
        target: this.fbo.write
      });
      
      this.fbo.swap();
      
      // Update uniforms
      this.fluidProgram.uniforms.tFluid.value = this.fbo.read.texture;
      this.fluidProgram.uniforms.uMouse.value = [this.mouse.x, this.mouse.y];
      this.fluidProgram.uniforms.uVelocity.value = [this.velocity.x, this.velocity.y];
      this.fluidProgram.uniforms.uTime.value = time;
      
      this.displayProgram.uniforms.tFluid.value = this.fbo.read.texture;
      this.displayProgram.uniforms.uMouse.value = [this.mouse.x, this.mouse.y];
      this.displayProgram.uniforms.uTime.value = time;
      
      // Render to screen
      this.renderer.render({
        scene: this.displayMesh,
        camera: this.camera
      });
      
      // Decay velocity
      this.velocity.x *= 0.9;
      this.velocity.y *= 0.9;
      
      requestAnimationFrame(() => this.render());
    }
  }
  
  // Initialize when DOM is loaded
  document.addEventListener('DOMContentLoaded', () => {
    new FluidCursor();
  });
</script>

<style>
  #fluid-cursor-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    pointer-events: none;
    z-index: 1;
    mix-blend-mode: screen;
    opacity: 0.8;
    font-family: 'Geist Mono', monospace;
    user-select: none;
  }
</style>